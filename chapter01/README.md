# Chapter 01. 자바 8, 9, 10, 11 : 

#        무슨 일이 일어나고 있는가?



>  생태계의 흐름에 맞춰 변화하는 자바
>
> 자바 8의 새로운 기능들이 어떻게 생기게 되었을까?
>
> 자바 8~11 등 전체적인 책의 내용 요약



## 1.1 역사의 흐름은 무엇인가?

자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다.

자바 9, 10에서도 중요한 변화가 있었지만 자바 8만큼 획기적이거나 생산성이 바뀌는 것은 아니다.

물론 이런 크고 작은 변화 덕에 프로그램을 더 쉽게 구현할 수 있게 되었다.



> 이전의 사과를 정렬하는 코드

```java
Collections.sort(inventory, new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
});
```



> 자바 8 이후의 사과를 정렬하는 코드

```java
inventory.sort(comparing(Apple::getWeight));
```

자바 8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드를 구현할 수 있다.



스레드를 사용하면 다중 코어를 사용할 수 있다. 하지만 관리하기 어렵고 많은 문제가 발생한다는 단점이 있다.

자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.

자바 1.0에서의 스레드와 락, 메모리 모델이 있었고, 자바 5에서의 스레드 풀, 병렬 실행 컬렉션, 자바7에서의 포크/

조인 프레임워크 등을 제공했지만 모두 여전히 개발자가 활용하기는 쉽지 않았다.



자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.



자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드



자바 8은 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 **스트림 API**를 제공한다.

스트림은 고수준 언어로 원하는 동작을 표현하면, 최적의 저수준 실행방법을 선택하는 방식으로 동작한다.

즉, 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 훨씬 비싼 키워드 syncronized를

사용하지 않아도 된다.



자바 8 기법은 **함수형 프로그래밍**^functional-style^ ^programming^에서 위력을 발휘한다.

코드를 전달하거나 조합해서 강력한 프로그래밍 도구로 활용할 수 있다는 것을 이 책에서 배울 수 있다.



## 1.2 왜 아직도 자바는 변화하는가?

프로그래밍 언어 생태계에는 변화의 바람이 불었다. 다른 프로그래밍 영역에서 대용량 데이터와 멀티코어 CPU를 효과적으로 활용하는 모습을 본 적이 있을 것이다.

그래서 자바 8도 더 다양한 프로그래밍 도구, 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수 할 수 있다는 장점들을 제공하게 되었다. 자바 8에 추가된 기능은 자바에 없던 새로운 개념이지만 현재 시장에서 요구하는 기능을 효과적으로 제공한다.

여기선 병렬성을 활용하는 코드, 간결한 코드를 구현할 수 있게한 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념을 설명한다.



### 1.2.2 스트림 처리

자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다. Stream<T>는 T 형식으로 구성된 일련의 항목을 의미한다. 예로 유닉스 명령어로 복잡한 파이프라인을 구성했던 것처럼 스트림 API는 파이프라인을 만드는데 필요한 많은 메서드를 제공한다.

스트림의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 **우리가 하려는 작업을 고수준으로 추상화해서 일련의 스트림으로 만들어 처리**할 수 있다. 

또한 스트림 파이프라인을 이용해서 입력 부분을 **여러 CPU 코어에 쉽게 할당할 수 있다**.

**스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성**을 얻을 수 있다.



### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.

예를  들어 sort 메서드에 파라미터를 전달하여 역순 정렬 등 다양한 정렬을 수행할 수는 있지만 어쨋든 sort로 
수행할 수 있는 동작은 미리 정해져있다.

예를 들어, `2013UK0001`, `2014US0002`... 같은 형식을 갖는 송장 ID들이 있다고 하자.

-  `2013`  = 연도
-  `UK` = 국가 코드
- `0001` = 고객 ID

일 때, 이 송장 ID를 고객 ID 또는 국가 코드 순으로 정렬해야한다면? sort에 따로 코드를 제공해야 할 것이다.

그렇다면 우리가 지정하는 순서대로 자료를 정리하도록 sort에 명령을 내려야한다.
우선은 두 송장 ID를 고객 ID를 사용해 비교하는 `compareUsingCustomerId` 메서드를 구현한다고 치자.

자바 8 이전의 자바에서는 메서드를 전달할 방법이 없었지만, 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.

이러한 기능을   이론적으로 **동작 파라미터화**^behavior^ ^parameterization^라고 부른다.



> 동작 파라미터화를 이용한 정렬

```java
private int compareUsingCustomerId(String inv1, String inv2) {
  return inv1.subString(6, 10).compareTo(inv2.subString(6,10));
}

public static void main(String[] args) {
  List<String> songjangs = 
    new ArrayList<(List.of("2013UK0003","2012US0002","2015KR0001"));
    
  songjangs.sort(new Example()::compareUsingCustomerId);
  System.out.println(songjangs);
}
```

동적 파라미터화가 왜 중요할까? `compareUsingCustomerId`를 이용해 sort의 동작을 파라미터화 했던 것 처럼
스트림 API는 연산의 동작을 파라미터화 할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다.

![image-20191121022422457](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20191121022422457.png)



### 1.2.4 병렬성과 공유 가변 데이터

세 번째 프로그래밍 개념은 `병렬성을 공짜로 얻을 수 있다`라는 말에서 시작된다.

하지만 세상에는 공짜는 없듯이 병렬성을 얻는 대신에 스트림 메서드로 전달하는 코드의 동작 방식을 바꿔야 한다.

**스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.**

그러기 위해서는 공유된 가변 데이터^shared^ ^mutable^ ^data^에 접근하지 않아야 한다.

> 이러한 함수를 **순수^pure^ 함수**, **부작용 없는^side-effect-free^ 함수**, **상태 없는^stateless^ 함수**라 부른다. (18, 19장)

지금까지는 독립적으로 실행될 수 있는 다중 코드 사본과 관련된 병렬성을 고려했다.

하지만 공유된 변수나 객체가 있으면 병렬성에 문제가 발생한다.  (이런 문제를 어떻게 해결하는지 나중 장에서..)

물론 `synchronized`를 이용해서 공유된 가변 데이터를 보호 할 수도 있지만 시스템에 악영향을 미치게 된다.

하지만 자바 8 스트림을 사용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다.



**공유되지 않은 가변 데이터^no-shared-mutable-data^**, **메서드나 함수 코드를 다른 메서드로 전달**하는 두 가지 기능은

**함수형 프로그래밍** 패러다임의 핵심적인 사항이다.

함수형 프로그래밍에서는 **우리가 하려는 작업**이 최우선시되며 그 작업을 어떻게 수행하는지는 별개의 문제로 취급한다. 극단적으로 생각하면 전통적인 객체지향 프로그래밍과 함수형 프로그래밍은 완전히 상극이다.

자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용할 수 있게 됐다.



이제 지금까지 살펴본 자바 8에 추가된 새로운 개념들을 하나씩 자세히 살펴보자.



## 1.3 자바 함수

프로그래밍 언어에서 **함수^function^**라는 용어는 **메서드^method^** 특히 정적 메서드^static-method^와 같은 의미로 사용된다.

자바의 함수는 이에더해 **수학적인 함수**처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.

자바 8에서는 스트림과 연계될 수 있도록 함수를 새로운 값의 형식으로 추가했다.  이 특징이 어떤 장점을 주는지  살펴보자.

자바 에서 조작할 수 있는 값을 생각해보자.

- 기본 값 : 42(int), 3.14(double) 등
- 객체 : new, 팩토리 메서드, 라이브러리 함수를 통해 객체의 값을 얻을 수 있다.

객체 참조는 클래스의 **인스턴스^instance^**를 가리킨다. 다양한 방법으로 객체 참조를 얻을 수 있다.

그런데 왜 함수가 필요할까? 프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 그리고 전통적으로 프로그래밍 언어에서는 이 바꿀 수 있는 값을 **일급^first-class^값** (또는 일급 시민)이라고 부른다.  (위의 값들은 모두 일급 값)

자바 언어의 다양한 구조체(메서드, 클래스)가 값의 구조를 표현하는데 도움이 될 수 있다.

하지만 모든 구조체를 자유롭게 전달할 수 없다. 이렇게 전달할 수 없는 구조체를 **이급값**(또는 시민)이라고 한다.

인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 유용하게 활용할 수 있지만 여전히 메서드와 클래스는 그 자체로 값이 될 수 없다.

예를들어 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다. 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.



### 1.3.1 메서드와 람다를 일급 시민으로

스칼라와 그루비같은 언어에서 메서드를 일급값으로 사용하면  프로그래밍이 수월해진다는 사실이 이미 실험을 통해 확인되었다. 이러한 강력한 기능 덕에 일급 시민이 부족한 다른 언어의 사용을 기피하는 현상까지 발생했다.

그래서 자바 8의 설계자들은 메서드를 값으로 취급할 수 있게, 프로그래머들이 더 쉽게 프로그램을 구현할 수 있는 환경이 제공되도록 자바 8을 설계하기로 결정했다.

이 결정이 스트림과 같은 다른 자바 8기능의 토대를 제공했다.



첫 번째로 **메서드 참조^method-reference^**를 알아보자.



> 주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
  public boolean accept(File file) {
    return file.isHidden(); //File 클래스에서 제공하는 메서드
  }
});
```

단 세행의 코드이지만 무슨 작업을 하는지 투명하지 않다. File 클래스에 이미 isHidden이라는 메서드가 있는데
왜 굳이 FileFilter로 복잡하게 감싼 다음에 FileFilter를 인스턴스화 해야할까? 자바 8 전에는 달리 방법이 없었다.



> 자바 8 이후의 코드

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

이미 isHidden이라는 함수는 준비 되어있으므로 자바 8의 **메서드 참조** ::('이 메서드를 값으로 사용하라'는 의미)를아용해서 listFiles에 직접 전달할 수 있다.

자바 8에서는 더이상 메서드가 이급값이 아닌 일급값이다. 메서드는 코드를 포함하고 있으므로 코드를 마음대로
전달할 수 있게 되었다.



#### 람다 : 익명 함수

자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 **람다**(또는 익명 함수^annonymous-function^)를 포함하여 함수도 값으로 취급할 수 있다. 

이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 간결한 코드를 구현할 수 있다.

람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 '함수를 일급 값으로 넘겨주는 프로그램'이라 한다.

![image-20191121163526387](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20191121163526387.png)



### 1.3.3 메서드 전달에서 람다로

메서드를 값으로 전달하는 것은 분명 유용한 기능이다. 하지만 한두 번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다.  자바 8에서는 이 문제도 간단히 해결할 수 있다.

`filterApples(inventory, Apple::isGreenApple);`

->

`filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));`



즉, 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다. 하지만 람다가 몇 줄 이상으로 길어진다면 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 좋다.
간결함 보다는 코드의 명확성이 우선시되어야 한다.



## 1.4 스트림

거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 다음 코드처럼 많은 기본 코드를 구현해야 한다

![image-20191121171510859](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20191121171510859.png)

스트림 API를 이용하면 다음처럼 해결할 수 있다.

![image-20191121171550526](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20191121171550526.png)

스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 모든 데이터가 라이브러리 내부에서 처리되기 때문이다.
이와 같은 반복을 **내부 반복^internal-iteration^**이라고 한다.

이론적으로 8개 코어를 가졌다면 병렬로 작업을 수행하여 단일 CPU 컴퓨터에 비해 8배 빨리 처리할 수 있다.



### 1.4.1 멀티스레딩은 어렵다

자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제' 그리고 '멀티코어 활용 어려움' 이라는 두 가지 문제 모두 해결했다. 기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴

- 스트림 기능
  - 데이터를 **필터링(filtering)** 하거나 데이터를 **추출(extracting)** 하거나, 데이터를 **그룹화(grouping)** 하는 등의 기능
  - 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하는 **포킹 단계(forking step)** 기능 마지막으로 하나의 CPU가 두 결과를 정리한다.

![image-20191121194037154](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20191121194037154.png)

- **순차 처리 방식 코드**

  ```
  import static java.util.stream.Collectors.toList;
  List<Apple> heavyApples =
    inventory.stream().filter((Apple a) -> a.getWeight() > 150)
    									. collect(toList());
  ```

  > stream() 을 사용

- **병렬 처리 방식의 코드**

  ```
  import static java.util.stream.Collectors.toList;
  List<Apple> heavyApples =
    inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
    													.collect(toList());
  ```

  > parallelStream()을 사용



# 1.5. 디폴트 메서드와 자바 모듈

- 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 **모듈을** 정의할 수 있다. (14장)

- 자바 8에서는 인터페이스를 **쉽게 바꿀 수 있도록 디폴트 메서드를** 지원한다. 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.

  - **예시) List 인터페이스에 정렬 디폴트 메소드 정의**

    ```
    default void sort(Comparator<? super E> c) {
      Collections.sort(this, c);
    }
    ```

    > 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.



## 1.6. 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 **Optional 클래스를** 제공한다.

- **Optional**
- 값을 갖거나 갖지 않을 수 있는 컨테이너 객체이다.



- **패턴 매칭**

  스칼라 프로그래밍 언어

  ```
  def simpleifyExpression(expr: Expr): Expr = expr match {
    case BinOp("+", e, Number(0)) => e
    case BinOp("-", e, Number(0)) => e
    case BinOp("*", e, Number(1)) => e
    case BinOp("/", e, Number(1)) => e
    case _ => expr
  }
  ```

  > 데이터 형식 분류와 분석을 한 번에 수행할 수 있다.



- 자바 12의 switch

   http://blog.naver.com/PostView.nhn?blogId=kgw1988&logNo=221478447511&categoryNo=33&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPag 

  

# 1.7. 마치며

- 함수는 일급값이다. **메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지** 기억하자.
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. **스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있다.**
- 자바 9에서는 **모듈을 이용해 시스템의 구조를 만들 수 있고 디폴트 메소드를 이용해 기존 인터페이스를 구현하는 클래스를 바꾸지 않고도 인터페이스를 변경할 수 있다.**
- 함수형 프로그래밍에서 **null 처리 방법과 패턴 매칭 활용** 등 흥미로운 기법을 발견했다.

- C, C++ 는 프로그래밍 안전성은 부족하지만 작은 런타임 풋프린트(footprint) 덕분에 운영체제와 다양한 임베디드 시스템에서 여전히 인기를 끌고 있다. 하지만 C, C++의 낮은 안정성 때문에 프로그램이 예기치 않게 종료되거나 바이러스 등이 침투할 수 있는 보안 구멍이 있을 수 있다.

- 자바는 지난 1995년 첫 베타 버전이 공개된 이후로 경쟁 언어로 대신하며 커다란 생태계를 성공적으로 구축했다.